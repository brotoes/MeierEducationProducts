<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>SPR_cycle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//list of cards in the cycle, in the order they were put there
elements_listid = ds_list_create()
persistent_variables = instance_find(OBJ_persistent_variables, 0)
battle_controller = instance_find(OBJ_battle_controller, 0)
action_bar = instance_find(OBJ_action_bar, 0)

//generate data to draw self
center_x = x + sprite_width/2
center_y = y + sprite_width/2
radius = 51
angle_increment = 360.0/5
angle_start = -90
point_seq_x[0] = 0
point_seq_y[0] = 0
for (i = 0; i &lt; 5; i ++) {
    angle = angle_start + angle_increment*i
    point_seq_x[i] = cos(degtorad(angle))*radius + center_x
    point_seq_y[i] = sin(degtorad(angle))*radius + center_y
}
element_colors[ELEMENT_NULL] = c_black
element_colors[ELEMENT_FIRE] = c_red
element_colors[ELEMENT_EARTH] = c_yellow
element_colors[ELEMENT_METAL] = c_purple
element_colors[ELEMENT_WATER] = c_blue
element_colors[ELEMENT_WOOD] = c_green

//the current level of each element (may change throughout the battle) 
element_levels[ELEMENT_NULL] = 0
//the current baseline level of each element (only reset after the battle ends)
element_bases[ELEMENT_NULL] = 0

previous_element_count = 0

for (i = ELEMENT_FIRE; i &lt; ELEMENT_NULL; i ++) {
    element_levels[i] = persistent_variables.element_base[i]
    element_bases[i] = persistent_variables.element_base[i]
}

last_played = ELEMENT_NULL

menu_waiting = false
menu_open = false
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//OPEN MENU
if (menu_waiting) {
    menu_waiting = false
    menu_open = true
    //create buttons
    instance_create(x, y, OBJ_battle_skip)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//find and set element levels
element_count = ds_list_size(elements_listid)
if (previous_element_count &lt; element_count) {
    card = ds_list_find_value(elements_listid, element_count - 1)
    if (element_count == 1) {
        element_levels[card.element] = 1
        last_played = card.element
        action_bar.points += 1
        if (card.element == ELEMENT_WATER) {
            action_bar.points -= 0.5
        }
    } else if ((ds_list_find_value(elements_listid, element_count - 2).element + 1) mod ELEMENT_NULL
        == card.element) {
        //valid selection
        element_levels[card.element] = element_levels[(card.element + 
                                        (ELEMENT_NULL - 1)) mod ELEMENT_NULL] + 1
        last_played = card.element
        action_bar.points += 1
        if (card.element == ELEMENT_WATER) {
            action_bar.points -= 0.5*element_levels[ELEMENT_WATER]
        }
    } else {
        //invalid selection
        card.selected = false
        //TODO flash next element?
        ds_list_delete(elements_listid, element_count - 1)
    }
    
    previous_element_count = element_count
} else if (previous_element_count &gt; element_count) {
    //clear element list
    for (i = 0; i &lt; element_count; i ++) {
        card = ds_list_find_value(elements_listid, i)
        card.selected = false
    }
    ds_list_clear(elements_listid)
    previous_element_count = 0
    last_played = ELEMENT_NULL
    action_bar.points = action_bar.prev_points
    
    for (i = 0; i &lt; ELEMENT_NULL; i ++) {
        element_levels[i] = 0
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*detect click, and play cycle*/
//detect click, and set flag
click = false
target_exists = false
card_selected = false
menu_waiting = false
menu_open = false

if (battle_controller.target != OBJ_null) {
    target_exists = true
}

if (ds_list_size(elements_listid) &gt; 0) {
    card_selected = true
}

if (point_distance(mouse_x, mouse_y, center_x, center_y) &lt; radius + 20) {
    click = true
}

//test for opened menu
//TODO

//play cycle if clicked
if (click &amp;&amp; target_exists &amp;&amp; card_selected &amp;&amp; not menu_open) {
    //get target object
    target = battle_controller.target
    if (target.object_index != OBJ_null) {
        //calculate damage
        total_damage = 0
        multiplier = DMG_NORMAL
        if ((last_played + 2) mod ELEMENT_NULL == target.primary_element) {
            multiplier = DMG_COUNTER
        } else if ((last_played + 1) mod ELEMENT_NULL == target.primary_element) {
            multiplier = DMG_FEED
        }
        damage = persistent_variables.base_damage
        damage *= element_levels[last_played]
        damage *= multiplier
        //perform element specific actions
        switch (last_played) {
            case ELEMENT_FIRE: {
                damage *= 2
            } break
            case ELEMENT_EARTH: {
                battle_controller.hp_current += 
                    SCR_get_heal_amnt(element_levels[ELEMENT_EARTH])
                if (battle_controller.hp_current &gt; persistent_variables.hp) {
                    battle_controller.hp_current = persistent_variables.hp
                }
            } break
            case ELEMENT_METAL: {
                target.stun = true
                audio_play_sound(S_metal, PRIORITY_ATTACK_SOUND, false)
            } break
            case ELEMENT_WOOD: {
                target.poison = element_levels[last_played]
            }
        }
        total_damage += damage
        //delete cards played
        for (i = 0; i &lt; ds_list_size(elements_listid); i ++) {
            to_destroy = ds_list_find_value(elements_listid, i)
            with (to_destroy) instance_destroy()
        }
        //clear list and reset element_levels
        ds_list_clear(elements_listid)
        for (i = 0; i &lt; ELEMENT_NULL; i ++) {
            element_levels[i] = 0
        }

        //apply damage to target object
        target.hp_current -= total_damage
        if (target.hp_current &gt; target.hp_total) {
            target.hp_current = target.hp_total
        }
        //create damage indicator
        indicator_offset = sprite_get_width(target.sprite_index)/2
        indicator = instance_create(target.x + indicator_offset, target.y + 50,
                                    OBJ_floating_number)
        indicator.value = string(total_damage)
        indicator.color = c_red
        
        previous_element_count = 0
        //increment turn if no cards left, or cycle is empty, or action bar full TODO
        if (action_bar.points &gt;= MAX_POINTS or action_bar.points == action_bar.prev_points) {
            battle_controller.whose_turn ++
            action_bar.points = 0
            action_bar.prev_points = 0
        } else {
            action_bar.prev_points = action_bar.points
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*detect click, and play cycle*/
//detect click, and set flag
click = false
menu_open = false

if (point_distance(mouse_x, mouse_y, center_x, center_y) &lt; radius + 20) {
    click = true
}

//play cycle if clicked
if (click) {
    menu_waiting = true
    alarm[0] = 40
}  
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self()

index = ds_list_size(elements_listid) - 1
for(i = ELEMENT_FIRE; i &lt; ELEMENT_NULL; i ++) {
    if (i == last_played) {
        draw_set_color(c_white)
    } else {
        draw_set_color(element_colors[i])
    }
    if (element_levels[i] == 0) {
        draw_sprite(SPR_cycle_elems, i*2, point_seq_x[i], point_seq_y[i])
    } else {
        draw_sprite(SPR_cycle_elems, i*2+1, point_seq_x[i], point_seq_y[i])
    }
    //draw text to indicate element level
    //draw_set_color(c_black)
    //draw_text(point_seq_x[i] - 5, point_seq_y[i] - 5, element_levels[i])
}

if (menu_open) {
    draw_set_alpha(0.5)
    draw_set_color(c_black)
    draw_rectangle(0, 0, room_width, room_height, false)
    draw_set_alpha(0.5)
    draw_circle(center_x, center_y, 350, false)
    draw_set_alpha(1)
}

draw_set_color(c_black)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
