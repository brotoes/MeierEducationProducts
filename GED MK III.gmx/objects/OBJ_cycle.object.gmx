<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>SPR_cycle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*This is mostly finished. There are two bugs I'm aware of: after
 *increasing the base level of an element, the fill circle that indicates
 *which one was clicked last is not filled in.
 *The second, you cannot get chains going that start with different elements
 *from the one you start making first.
 */

//list of cards in the cycle, in the order they were put there
elements_listid = ds_list_create()
card_null = instance_create(x, y, OBJ_element_container)
card_null.element = ELEMENT_NULL
ds_list_add(elements_listid, card_null)
persistent_variables = instance_find(OBJ_persistent_variables, 0)
battle_controller = instance_find(OBJ_battle_controller, 0)
action_bar = instance_find(OBJ_action_bar, 0)

//size of the cycle, change this to have the cycle rendered differently
size = sprite_get_width(SPR_card_stack)

//generate data to draw self
center_x = x + size/2
center_y = y + size/2
radius = size/2
angle_increment = 360.0/5
angle_start = -90
point_seq_x[0] = 0
point_seq_y[0] = 0
subcircle_radius = radius/5
for (i = 0; i &lt; 5; i ++) {
    angle = angle_start + angle_increment*i
    point_seq_x[i] = cos(degtorad(angle))*radius + center_x
    point_seq_y[i] = sin(degtorad(angle))*radius + center_y
}
element_colors[ELEMENT_NULL] = c_black
element_colors[ELEMENT_FIRE] = c_red
element_colors[ELEMENT_EARTH] = c_yellow
element_colors[ELEMENT_METAL] = c_purple
element_colors[ELEMENT_WATER] = c_blue
element_colors[ELEMENT_WOOD] = c_green

//the current level of each element (may change throughout the battle) 
element_levels[ELEMENT_NULL] = 0
//the current baseline level of each element (only reset after the battle ends)
element_bases[ELEMENT_NULL] = 0

previous_element_count = 0

for (i = ELEMENT_FIRE; i &lt; ELEMENT_NULL; i ++) {
    element_levels[i] = persistent_variables.element_base[i]
    element_bases[i] = persistent_variables.element_base[i]
}

last_played = card_null
//used to determine what elements are used to deal damage
chain_ends_listid = ds_list_create()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//delete cards played
for (i = 1; i &lt; ds_list_size(elements_listid); i ++) {
    to_destroy = ds_list_find_value(elements_listid, i)
    with (to_destroy) instance_destroy()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//find and set element levels
element_count = ds_list_size(elements_listid)
if (previous_element_count != element_count) {
    //number of action points gained from played water cards
    water_reductions = 0
    
    //set elements to their respective base levels
    for (i = ELEMENT_FIRE; i &lt; ELEMENT_NULL; i ++) {
        element_levels[i] = element_bases[i]
    }
    
    chains_listid = ds_list_create()
    last_element = ELEMENT_NULL
    cur_chain_length = 0

    //find all chains of elements and their respective lengths
    for (i = 0; i &lt; element_count; i ++) {
        cur_element_card = ds_list_find_value(elements_listid, i)
        cur_element = cur_element_card.element
        if ((last_element + 1) % 5 == cur_element
            or last_element == ELEMENT_NULL and cur_element != ELEMENT_NULL) {
            cur_chain_length ++
            if (cur_element == ELEMENT_WATER) {
                water_reductions += cur_chain_length/2
            }
        } else if (cur_element != ELEMENT_NULL) {
            ds_list_add(chains_listid, cur_chain_length)
            cur_chain_length = 1
            if (cur_element == ELEMENT_WATER) {
                water_reductions += 0.5
            }
        }
        if (i == element_count - 1) {
            ds_list_add(chains_listid, cur_chain_length)
        }
        last_element = cur_element
    }
    chain_start = 0
    
    //use chains to find levels of each element
    for (chain = 0; chain &lt; ds_list_size(chains_listid); chain ++) {
        for (link = 0; link &lt;= ds_list_find_value(chains_listid, chain); link ++) {
            ds_list_clear(chain_ends_listid)
            index = ds_list_find_value(elements_listid, link + chain_start).element
            new_level = link + element_bases[index]
            if (new_level &gt; element_levels[index]) {
                element_levels[index] = new_level
            }
            if (new_level &gt; 5) {
                ds_list_clear(elements_listid)
                ds_list_add(elements_listid, card_null)
                if (element_bases[index] &lt; 5) {
                    element_bases[index] ++
                }
                for (i = ELEMENT_FIRE; i &lt; ELEMENT_NULL; i ++) {
                    element_levels[i] = element_bases[i]
                }
            }
            //call on last iteration of for loop
            if (link == ds_list_find_value(chains_listid, chain)) {
                ds_list_add(chain_ends_listid, index)
            }
        }
        chain_start += ds_list_find_value(chains_listid, chain)
    }
    element_count = ds_list_size(elements_listid)
    previous_element_count = element_count
    ds_list_destroy(chains_listid)
    
    element_levels[ELEMENT_NULL] = 0
    //set action bar
    action_bar.points = element_count - 1
    //reduce points due to water
    action_bar.points -= water_reductions
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*detect click, and play cycle*/
//detect click, and set flag
click = false
target_exists = false

if (battle_controller.target != OBJ_null) {
    target_exists = true
}

if (point_distance(mouse_x, mouse_y, center_x, center_y) &lt; radius + 20) {
    click = true
}
//play cycle if clicked
if (click &amp;&amp; target_exists) {
    //get target object
    target = battle_controller.target
    if (target.object_index != OBJ_null) {
        //calculate damage
        //TODO figure out damage formula
        total_damage = 0
        for(i = 0; i &lt; ds_list_size(chain_ends_listid); i ++) {
            multiplier = DMG_NORMAL
            element = ds_list_find_value(chain_ends_listid, i)
            if ((element + 2) % ELEMENT_NULL == target.primary_element) {
                multiplier = DMG_COUNTER
            } else if ((element + 1) % ELEMENT_NULL == target.primary_element) {
                multiplier = DMG_FEED
            }
            damage = persistent_variables.base_damage
            damage += element_levels[element]
            damage *= multiplier
            //perform element specific actions
            switch (element) {
                case ELEMENT_FIRE: {
                    damage *= 2
                } break
                case ELEMENT_EARTH: {
                    //TODO: find GOOD formula for amount healed
                    battle_controller.hp_current += 10 * element_levels[element]
                    if (battle_controller.hp_current &gt; persistent_variables.hp) {
                        battle_controller.hp_current = persistent_variables.hp
                    }
                } break
                case ELEMENT_METAL: {
                    target.stun = true
                } break
                case ELEMENT_WATER: {
                    //TODO: action points gained
                    //NOTE: Perhaps this should be done when selecting the card?
                } break
                case ELEMENT_WOOD: {
                    target.poison = element_levels[element]
                }
            }
            total_damage += damage
        }
        //set deletion alarm for cards played
        alarm[0] = 2

        //apply damage to target object
        target.hp_current -= total_damage
        if (target.hp_current &gt; target.hp_total) {
            target.hp_current = target.hp_total
        }
        //create damage indicator
        indicator_offset = sprite_get_width(target.sprite_index)/2
        indicator = instance_create(target.x + indicator_offset, target.y + 50,
                                    OBJ_floating_number)
        indicator.value = string(total_damage)
        indicator.color = c_red
        //increment turn if no cards left, or cycle is empty
        battle_controller.whose_turn ++
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*background*/
draw_set_color(c_white)
draw_set_alpha(0.5)
draw_circle(center_x, center_y, radius + 20, false)

draw_set_color(c_black)
draw_set_alpha(1)
draw_circle(center_x, center_y, radius + 1, true)
draw_circle(center_x, center_y, radius, true)
draw_circle(center_x, center_y, radius - 1, true)

for(i = 0; i &lt; 5; i ++) {
    draw_line(point_seq_x[i], point_seq_y[i], 
        point_seq_x[(i + 2) % 5], point_seq_y[(i + 2) % 5])
}

index = ds_list_size(elements_listid) - 1
recent_card = ds_list_find_value(elements_listid, index)

recent_element = recent_card.element

for(i = ELEMENT_FIRE; i &lt; ELEMENT_NULL; i ++) {
    if (i == recent_element) {
        draw_set_color(c_white)
    } else {
        draw_set_color(element_colors[i])
    }
    draw_circle(point_seq_x[i], point_seq_y[i], subcircle_radius, false)
    //draw text to indicate element level
    draw_set_color(c_black)
    draw_text(point_seq_x[i] - 5, point_seq_y[i] - 5, element_levels[i])
}

draw_set_color(c_black)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
