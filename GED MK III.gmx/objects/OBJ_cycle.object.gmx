<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>SPR_cycle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*This is mostly finished. There are two bugs I'm aware of: after
 *increasing the base level of an element, the fill circle that indicates
 *which one was clicked last is not filled in.
 *The second, you cannot get chains going that start with different elements
 *from the one you start making first.
 */

//list of cards in the cycle, in the order they were put there
elements_listid = ds_list_create()
ds_list_add(elements_listid, ELEMENT_NULL)
persistent_variables = instance_find(OBJ_persistent_variables, 0)

//size of the cycle, change this to have the cycle rendered differently
size = sprite_get_width(SPR_card_stack)

//generate data to draw self
center_x = x + size/2
center_y = y + size/2
radius = size/2
angle_increment = 360.0/5
angle_start = -90
point_seq_x[0] = 0
point_seq_y[0] = 0
subcircle_radius = radius/5
for (i = 0; i &lt; 5; i ++) {
    angle = angle_start + angle_increment*i
    point_seq_x[i] = cos(degtorad(angle))*radius + center_x
    point_seq_y[i] = sin(degtorad(angle))*radius + center_y
}
element_colors[ELEMENT_NULL] = c_black
element_colors[ELEMENT_FIRE] = c_red
element_colors[ELEMENT_EARTH] = c_yellow
element_colors[ELEMENT_METAL] = c_purple
element_colors[ELEMENT_WATER] = c_blue
element_colors[ELEMENT_WOOD] = c_green

//the current level of each element (may change throughout the battle) 
element_levels[ELEMENT_NULL] = 0
//the current baseline level of each element (only reset after the battle ends)
element_bases[ELEMENT_NULL] = 0

previous_element_count = 0

for (i = ELEMENT_FIRE; i &lt; ELEMENT_NULL; i ++) {
    element_levels[i] = persistent_variables.element_base[i]
    element_bases[i] = persistent_variables.element_base[i]
}

last_played = ELEMENT_NULL
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//find and set element levels
element_count = ds_list_size(elements_listid)
if (previous_element_count != element_count) {
    for (i = ELEMENT_FIRE; i &lt; ELEMENT_NULL; i ++) {
        element_levels[i] = element_bases[i]
    }
    chains_listid = ds_list_create()
    last_element = ELEMENT_NULL
    cur_chain_length = 0
    show_debug_message("------------------")
    for (i = 0; i &lt; element_count; i ++) {
        cur_element = ds_list_find_value(elements_listid, i)
        show_debug_message(string(cur_element))
        if ((last_element + 1) % 5 == cur_element
            or last_element == ELEMENT_NULL and cur_element != ELEMENT_NULL) {
            cur_chain_length ++
        } else if (cur_element != ELEMENT_NULL) {
            ds_list_add(chains_listid, cur_chain_length)
            cur_chain_length = 1
        }
        if (i == element_count - 1) {
            ds_list_add(chains_listid, cur_chain_length)
        }
        last_element = cur_element
    }
    chain_start = 0
    for (chain = 0; chain &lt; ds_list_size(chains_listid); chain ++) {
        //show_debug_message("---------")
        for (link = 0; link &lt;= ds_list_find_value(chains_listid, chain); link ++) {
            index = ds_list_find_value(elements_listid, link + chain_start)
            //show_debug_message(string(index))
            new_level = link + element_bases[index]
            if (new_level &gt; element_levels[index]) {
                element_levels[index] = new_level
            }
            if (new_level &gt; 5) {
                ds_list_clear(elements_listid)
                ds_list_add(elements_listid, ELEMENT_NULL)
                if (element_bases[index] &lt; 5) {
                    element_bases[index] ++
                }
                for (i = ELEMENT_FIRE; i &lt; ELEMENT_NULL; i ++) {
                    element_levels[i] = element_bases[i]
                }
            }
        }
        chain_start += ds_list_find_value(chains_listid, chain)
    }
    element_count = ds_list_size(elements_listid)
    previous_element_count = element_count
    ds_list_destroy(chains_listid)
    
    element_levels[ELEMENT_NULL] = 0
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_circle(center_x, center_y, radius + 1, true)
draw_circle(center_x, center_y, radius, true)
draw_circle(center_x, center_y, radius - 1, true)

for(i = 0; i &lt; 5; i ++) {
    draw_line(point_seq_x[i], point_seq_y[i], 
        point_seq_x[(i + 2) % 5], point_seq_y[(i + 2) % 5])
}

for(i = ELEMENT_FIRE; i &lt; ELEMENT_NULL; i ++) {
    index = ds_list_size(elements_listid) - 1
    element = ds_list_find_value(elements_listid, index)
    fill = i != element

    draw_set_color(c_black)
    draw_circle(point_seq_x[i], point_seq_y[i], subcircle_radius, false)
    draw_set_color(element_colors[i])
    draw_circle(point_seq_x[i], point_seq_y[i], subcircle_radius, fill)
    for (j = 0; j &lt; element_levels[i]; j ++) {
        draw_circle(point_seq_x[i], point_seq_y[i], subcircle_radius + (j+1)*3, true)
    }
}

draw_set_color(c_black)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
