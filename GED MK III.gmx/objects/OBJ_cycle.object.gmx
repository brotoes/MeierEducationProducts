<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_cycle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-7500</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//list of cards in the cycle, in the order they were put there
elements_listid = ds_list_create()
battle = instance_find(obj_battle_con, 0)

//generate data to draw self
center_x = x + sprite_width/2
center_y = y + sprite_width/2
radius = 51
angle_increment = 360.0/5
angle_start = -90
point_seq_x[0] = 0
point_seq_y[0] = 0
for (i = 0; i &lt; 5; i ++) {
    angle = angle_start + angle_increment*i
    point_seq_x[i] = cos(degtorad(angle))*radius + center_x
    point_seq_y[i] = sin(degtorad(angle))*radius + center_y
}

//the current level of each element
element_levels[ELEMENT_NULL] = 0

for (i = ELEMENT_FIRE; i &lt; ELEMENT_NULL; i ++) {
    element_levels[i] = 0
}

last_played = ELEMENT_NULL
previous_element_count = 0
menu_waiting = false
menu_open = false

anim_counter = 0
flash_counter = 0
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_list_destroy(elements_listid)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//OPEN MENU
if (menu_waiting) {
    menu_waiting = false
    menu_open = true
    //create buttons
    children_listid = get_children(obj_battlemenu_par)
    for(i = 0; i &lt; ds_list_size(children_listid); i ++) {
        obj = ds_list_find_value(children_listid, i)
        instance_create(x, y, obj)
    }
    ds_list_destroy(children_listid)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//find and set element levels
element_count = ds_list_size(elements_listid)
if (previous_element_count &lt; element_count) {
    card = ds_list_find_value(elements_listid, element_count - 1)
    if (element_count == 1) {
        element_levels[card.element] = 1
        last_played = card.element
        action_bar.points += 1
    } else if ((ds_list_find_value(elements_listid, element_count - 2).element + 1) mod ELEMENT_NULL
        == card.element) {
        //valid selection
        element_levels[card.element] = element_levels[(card.element + 
                                        (ELEMENT_NULL - 1)) mod ELEMENT_NULL] + 1
        last_played = card.element
        action_bar.points += 1
    } else {
        //invalid selection
        card.selected = false
        //TODO flash next element?
        ds_list_delete(elements_listid, element_count - 1)
    }
    
    previous_element_count = element_count
} else if (previous_element_count &gt; element_count) {
    //clear element list
    for (i = 0; i &lt; element_count; i ++) {
        card = ds_list_find_value(elements_listid, i)
        card.selected = false
    }
    ds_list_clear(elements_listid)
    previous_element_count = 0
    last_played = ELEMENT_NULL
    action_bar.points = action_bar.prev_points
    
    for (i = 0; i &lt; ELEMENT_NULL; i ++) {
        element_levels[i] = 0
    }
}

anim_counter ++
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*detect click, and play cycle*/
//detect click, and set flag
click = false
target_exists = false
card_selected = false
menu_waiting = false
menu_open = false

if (battle.target != obj_null) {
    target_exists = true
}

if (ds_list_size(elements_listid) &gt; 0) {
    card_selected = true
}

if (point_distance(mouse_x, mouse_y, center_x, center_y) &lt; radius + 20) {
    click = true
}

//play cycle if clicked
if (click &amp;&amp; target_exists &amp;&amp; card_selected &amp;&amp; not menu_open) {
    //get target object
    target = battle.target
    //deselect target
    battle.target = obj_null
    if (target.object_index != obj_null) {
        //calculate damage
        total_damage = 0
        multiplier = DMG_NORMAL
        if ((last_played + 2) mod ELEMENT_NULL == target.primary_element) {
            multiplier = DMG_COUNTER
        } else if ((last_played + 1) mod ELEMENT_NULL == target.primary_element) {
            multiplier = DMG_FEED
        } else if ((last_played + 3) mod ELEMENT_NULL == target.primary_element) {
            multiplier = DMG_INSULT
        }
        damage = persvars.damage[persvars.upgrade[last_played]]
        damage *= multiplier
        damage *= element_levels[last_played]
        splash_listid = ds_list_create()
        //perform element specific actions
        switch (last_played) {
            case ELEMENT_FIRE: {
                //uncomment to damage all enemies at max level
                /*if (persistent_variables.upgrade[ELEMENT_FIRE] &gt;= 9) {
                    //make list of splash targets
                    ds_list_copy(splash_listid, battle_controller.enemy_listid)
                    del_ind = ds_list_find_index(splash_listid, target)
                    ds_list_delete(splash_listid, del_ind)
                } else */
                if (persvars.upgrade[ELEMENT_FIRE] &gt;= 6) {
                    //make list of splash targets
                    middle_ind = ds_list_find_index(battle.enemy_listid, target)
                    if (middle_ind != 0) {
                        left = ds_list_find_value(battle.enemy_listid, middle_ind - 1)
                        ds_list_add(splash_listid, left)
                    }
                    if (middle_ind &lt; ds_list_size(battle.enemy_listid) - 1) {
                        right = ds_list_find_value(battle.enemy_listid, middle_ind + 1)
                        ds_list_add(splash_listid, right)
                    }
                }    
                if (persvars.upgrade[ELEMENT_FIRE] &gt;= 3) {
                    damage *= 2
                }
            } break
            case ELEMENT_EARTH: {
                if (persvars.upgrade[ELEMENT_EARTH] &gt;= 3) {
                    battle.hp_current += 
                        get_heal(element_levels[ELEMENT_EARTH])
                    if (battle.hp_current &gt; battle.hp_max) {
                        battle.hp_current = battle.hp_max
                    }
                }
                if (persvars.upgrade[ELEMENT_EARTH] &gt;= 6) {
                    battle.player_dmg_mult = 0.5
                }
                if (persvars.upgrade[ELEMENT_EARTH] &gt;= 9) {
                    battle.player_dmg_mult = 0
                }
            } break
            case ELEMENT_METAL: {
                if (persvars.upgrade[ELEMENT_METAL] &gt;= 3) {
                    target.stun = max(1, target.stun)
                } else if (persistent_variables.upgrade[ELEMENT_METAL] &gt;= 6) {
                    target.stun = max(2, target.stun)
                } else if (persistent_variables.upgrade[ELEMENT_METAL] &gt;= 9) {
                    target.stun = max(3, target.stun)
                }
            } break
            case ELEMENT_WATER: {
                
            } break
            case ELEMENT_WOOD: {
                if (persvars.upgrade[ELEMENT_WOOD] &gt;= 3) {
                    target.poison += element_levels[last_played]
                }
                if (persvars.upgrade[ELEMENT_WOOD] &gt;= 6) {
                    target.leech += element_levels[last_played]
                }
            }
        }
        total_damage += damage
        //delete cards played
        for (i = 0; i &lt; ds_list_size(elements_listid); i ++) {
            to_destroy = ds_list_find_value(elements_listid, i)
            with (to_destroy) instance_destroy()
        }
        //clear list and reset element_levels
        ds_list_clear(elements_listid)
        for (i = 0; i &lt; ELEMENT_NULL; i ++) {
            element_levels[i] = 0
        }

        //apply damage to target object
        total_damage = battle_round(total_damage)
        target.hp_current -= total_damage
        if (target.hp_current &gt; target.hp_total) {
            target.hp_current = target.hp_total
        } else if (target.hp_current &lt; 0) {
            target.hp_current = 0
        }
        target.flash = target.flash_time
        target.flash_color = persvars.element_colors[last_played]
        
        //create damage indicator
        indicator_offset = sprite_get_width(target.sprite_index)/2
        indicator = instance_create(target.x + indicator_offset, target.y + 50,
                                    obj_text_part)
        indicator.value = string(total_damage)
        if (total_damage &gt;= 0) {
            indicator.color = c_red
        } else {
            indicator.color = c_blue
        }
        
        //apply splash damage
        splash_damage = abs(battle_round(total_damage*SPLASH_MULT))
        for (i = 0; i &lt; ds_list_size(splash_listid); i ++) {
            multiplier = DMG_NORMAL
            splash_target = ds_list_find_value(splash_listid, i)
            
            if ((last_played + 2) mod ELEMENT_NULL == splash_target.primary_element) {
                multiplier = DMG_COUNTER
            } else if ((last_played + 1) mod ELEMENT_NULL == splash_target.primary_element) {
                multiplier = DMG_FEED
            } else if ((last_played + 3) mod ELEMENT_NULL == splash_target.primary_element) {
                multiplier = DMG_INSULT
            }
            
            splash_damage *= multiplier
            splash_damage = battle_round(splash_damage)
            splash_target.hp_current -= splash_damage
            
            if (splash_target.hp_current &gt; splash_target.hp_total) {
                splash_target.hp_current = splash_target.hp_total
            } else if (splash_target.hp_current &lt; 0) {
                splash_target.hp_current = 0
            }
            splash_target.flash = splash_target.flash_time
            splash_target.flash_color = persvars.element_colors[last_played]
            
            //create damage indicator
            indicator_offset = sprite_get_width(splash_target.sprite_index)/2
            indicator = instance_create(splash_target.x + indicator_offset, splash_target.y + 50,
                                        obj_text_part)
            indicator.value = string(splash_damage)
            if (splash_damage &gt;= 0) {
                indicator.color = c_red
            } else {
                indicator.color = c_blue
            }
        }
        
        previous_element_count = 0
        //increment turn if no cards left, or cycle is empty, or action bar full TODO
        if (action_bar.points &gt;= MAX_POINTS or action_bar.points == action_bar.prev_points) {
            battle.whose_turn ++
            action_bar.points = 0
            action_bar.prev_points = 0
        } else {
            action_bar.prev_points = action_bar.points
        }
    }
    ds_list_destroy(splash_listid)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*detect click, and play cycle*/
//detect click, and set flag
click = false
menu_open = false

if (point_distance(mouse_x, mouse_y, center_x, center_y) &lt; radius + 20) {
    click = true
}

//play cycle if clicked
if (click and battle.whose_turn == 0 and instance_number(obj_battleoverlay_par) == 0) {
    menu_waiting = true
    alarm[0] = 20
}  
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self()

index = ds_list_size(elements_listid) - 1
reset_flash = true
for(i = ELEMENT_FIRE; i &lt; ELEMENT_NULL; i ++) {
    if (element_levels[i] == 0) {
        draw_sprite(spr_cycleelems, i*2, point_seq_x[i], point_seq_y[i])
    } else {
        draw_sprite(spr_cycleelems, i*2+1, point_seq_x[i], point_seq_y[i])
        if (i == last_played) {
            draw_set_alpha(max(cos(flash_counter/6), cos(flash_counter/6 + pi)))
            reset_flash = false
            draw_set_blend_mode(bm_add)
            draw_sprite(spr_cycleelems, i*2+1, point_seq_x[i], point_seq_y[i])
            draw_set_blend_mode(bm_normal)
            draw_set_alpha(1)
        }
    }
}
if (reset_flash) {
    flash_counter = 0
} else {
    flash_counter ++
}

if (menu_open) {
    draw_set_alpha(0.5)
    draw_set_color(c_black)
    draw_rectangle(0, 0, room_width, room_height, false)
    draw_set_alpha(0.5)
    draw_circle(center_x, center_y, 350, false)
    draw_set_alpha(1)
}

draw_set_color(c_black)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
